{"ast":null,"code":"/**\r\n * Función que devuelve todos los personajes por página y permite filtrar por el nombre\r\n * @param {string | undefined} name - El nombre del personaje por el cual filtrar (opcional).\r\n * @returns {Promise<[Personaje[], Page, number] | [any, any, number]>} Una matriz que contiene la lista de personajes, información de paginación y estado de respuesta, o un mensaje de error si la solicitud falla.\r\n */\nexport const getCharactersAPI = async name => {\n  let nameParam = \"\";\n  if (name !== \"\" && name !== undefined) {\n    if (name.includes(\" \")) {\n      const names = name.split(\" \");\n      nameParam = `name=${names[0]}%20${names[1]}`;\n    } else {\n      nameParam = `name=${name}`;\n    }\n  }\n  return fetch(`https://rickandmortyapi.com/api/character?${nameParam}`).then(async function (response) {\n    const data = await response.json();\n    return [data.results, data.info, response.status];\n  });\n};\n\n/**\r\n* Función que devuelve los personajes por página.\r\n* @param {string }url\r\n* @returns {Promise<[Personaje[], Page]>} Una matriz que contiene la lista de personajes y su información de paginación.\r\n*/\nexport const changePage = async url => {\n  return fetch(url).then(data => data.json()).then(data => [data.results, data.info]);\n};\n\n/**\r\n* Función que devuelve todos los episodios de un personaje.\r\n* @param {Array<number>} arrayEpisodeID\r\n* @returns {Promise<Episodio | Episodio[]>} Retorna todos los episodios de un personaje.\r\n*/\nexport const fetchEpisodes = async arrayEpisodeID => {\n  return (await fetch(`https://rickandmortyapi.com/api/episode/${arrayEpisodeID}`)).json();\n};","map":{"version":3,"names":["getCharactersAPI","name","nameParam","undefined","includes","names","split","fetch","then","response","data","json","results","info","status","changePage","url","fetchEpisodes","arrayEpisodeID"],"sources":["C:/Users/ALEX/Downloads/ctd-esp-fe1-final-main (2)/ctd-esp-fe1-final-main/src/services/personaje.services.ts"],"sourcesContent":["import Episodio from \"../types/episodio.types\";\r\nimport Page from \"../types/page.types\";\r\nimport Personaje from \"../types/personaje.types\";\r\n/**\r\n * Función que devuelve todos los personajes por página y permite filtrar por el nombre\r\n * @param {string | undefined} name - El nombre del personaje por el cual filtrar (opcional).\r\n * @returns {Promise<[Personaje[], Page, number] | [any, any, number]>} Una matriz que contiene la lista de personajes, información de paginación y estado de respuesta, o un mensaje de error si la solicitud falla.\r\n */\r\nexport const getCharactersAPI = async (\r\n  name?: string\r\n): Promise<[Personaje[], Page, number] | [any, any, number]> => {\r\n  let nameParam = \"\";\r\n  if (name !== \"\" && name !== undefined) {\r\n    if (name.includes(\" \")) {\r\n      const names = name.split(\" \");\r\n      nameParam = `name=${names[0]}%20${names[1]}`;\r\n    } else {\r\n      nameParam = `name=${name}`;\r\n    }\r\n  }\r\n  return fetch(`https://rickandmortyapi.com/api/character?${nameParam}`).then(\r\n    async function (response) {\r\n      const data = await response.json();\r\n      return [data.results, data.info, response.status];\r\n    }\r\n  );\r\n};\r\n\r\n/**\r\n* Función que devuelve los personajes por página.\r\n* @param {string }url\r\n* @returns {Promise<[Personaje[], Page]>} Una matriz que contiene la lista de personajes y su información de paginación.\r\n*/\r\nexport const changePage = async (\r\n  url: string\r\n): Promise<[Personaje[], Page]> => {\r\n  return fetch(url)\r\n    .then((data) => data.json())\r\n    .then((data) => [data.results, data.info]);\r\n};\r\n\r\n/**\r\n* Función que devuelve todos los episodios de un personaje.\r\n* @param {Array<number>} arrayEpisodeID\r\n* @returns {Promise<Episodio | Episodio[]>} Retorna todos los episodios de un personaje.\r\n*/\r\nexport const fetchEpisodes = async (\r\n  arrayEpisodeID: (string | undefined)[]\r\n): Promise<Episodio | Episodio[]> => {\r\n  return (\r\n    await fetch(`https://rickandmortyapi.com/api/episode/${arrayEpisodeID}`)\r\n  ).json();\r\n};\r\n"],"mappings":"AAGA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,gBAAgB,GAAG,MAC9BC,IAAa,IACiD;EAC9D,IAAIC,SAAS,GAAG,EAAE;EAClB,IAAID,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAKE,SAAS,EAAE;IACrC,IAAIF,IAAI,CAACG,QAAQ,CAAC,GAAG,CAAC,EAAE;MACtB,MAAMC,KAAK,GAAGJ,IAAI,CAACK,KAAK,CAAC,GAAG,CAAC;MAC7BJ,SAAS,GAAI,QAAOG,KAAK,CAAC,CAAC,CAAE,MAAKA,KAAK,CAAC,CAAC,CAAE,EAAC;IAC9C,CAAC,MAAM;MACLH,SAAS,GAAI,QAAOD,IAAK,EAAC;IAC5B;EACF;EACA,OAAOM,KAAK,CAAE,6CAA4CL,SAAU,EAAC,CAAC,CAACM,IAAI,CACzE,gBAAgBC,QAAQ,EAAE;IACxB,MAAMC,IAAI,GAAG,MAAMD,QAAQ,CAACE,IAAI,EAAE;IAClC,OAAO,CAACD,IAAI,CAACE,OAAO,EAAEF,IAAI,CAACG,IAAI,EAAEJ,QAAQ,CAACK,MAAM,CAAC;EACnD,CAAC,CACF;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAG,MACxBC,GAAW,IACsB;EACjC,OAAOT,KAAK,CAACS,GAAG,CAAC,CACdR,IAAI,CAAEE,IAAI,IAAKA,IAAI,CAACC,IAAI,EAAE,CAAC,CAC3BH,IAAI,CAAEE,IAAI,IAAK,CAACA,IAAI,CAACE,OAAO,EAAEF,IAAI,CAACG,IAAI,CAAC,CAAC;AAC9C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMI,aAAa,GAAG,MAC3BC,cAAsC,IACH;EACnC,OAAO,CACL,MAAMX,KAAK,CAAE,2CAA0CW,cAAe,EAAC,CAAC,EACxEP,IAAI,EAAE;AACV,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}